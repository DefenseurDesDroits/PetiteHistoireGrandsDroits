{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js","webpack:///./wordfind/src/wordfind.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;AClFA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC,C;;;;;;;;;;;;ACxDD;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,aAAa;AAC1B,aAAa,EAAE,0NAA0N,SAAS;AAClP,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,gBAAgB;AAC7B,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,eAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,gBAAgB,wBAAwB,YAAY,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4KAA4K,eAAe;AAC3L,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,gBAAgB,sBAAsB,YAAY,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;;AAEhB;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,QAAQ,mBAAmB,qBAAqB,wCAAwC,EAAE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,SAAS;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ,sBAAsB;AAC3C,aAAa,OAAO;AACpB,eAAe,QAAQ,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,cAAc,GAAG,eAAe;AACtE;AACA,gCAAgC,cAAc,GAAG,eAAe,oBAAoB,kBAAkB;AACtG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,QAAQ;AACzD,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,eAAe;AAC5B,eAAe,QAAQ,yEAAyE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,K;AACA;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uE","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/main.js\");\n","import wordFind from '../../wordfind/src/wordfind.js'\r\n\r\nconsole.warn(\"I am self aware\")\r\n\r\nfunction linkGame() {\r\n  return 0\r\n}\r\n\r\nvar words = [\r\n  'amour',\r\n  'avis',\r\n  'bien-être',\r\n  'bonheur',\r\n  'club',\r\n  'connaissance',\r\n  'convention',\r\n  'culture',\r\n  'développement',\r\n  'écrire',\r\n  'éducation',\r\n  'égalité',\r\n  'enfant',\r\n  'épanouissement',\r\n  'états',\r\n  'expression',\r\n  'famille',\r\n  'femme',\r\n  'harmonie',\r\n  'homme',\r\n  'humanité',\r\n  'idéaux',\r\n  'justice',\r\n  'liberté',\r\n  'loisirs',\r\n  'manifester',\r\n  'mineur',\r\n  'opinion',\r\n  'paix',\r\n  'parent',\r\n  'presse',\r\n  'principe',\r\n  'protection',\r\n  'religion',\r\n  'respect',\r\n  'santé',\r\n  'universel',\r\n  'vie'\r\n]\r\n\r\nvar puzzleElem = document.querySelector('#wordsgame')\r\n\r\nvar wordGame = new wordFind(words, puzzleElem, {\r\n  lang: 'FR',\r\n  orientations: ['horizontal', 'vertical'],\r\n  maxGridGrowth: 50,\r\n  preferOverlap: false\r\n})","/**\r\n *Create a words puzzle game\r\n * @class wordFind\r\n */\r\nclass wordFind {\r\n\r\n  /**\r\n   *Creates an instance of wordFind.\r\n   * @param {!Array.<string>} words list of words to include in the puzzle\r\n   * @param {!HTMLElement} domElem HTML DOM Element that will contain the game\r\n   * @param {!{lang: [!string], heigth: [!number], width: [!number], orientations: [!Array.<string>], fillBlanks: [!boolean], allowExtraBlanks: [!boolean], maxAttempts: [!number], maxGridGrowth: [!number], preferOverlap: [!boolean]}} [opts={}] game options\r\n   * @param {!string} [opts.lang] define the letters set to use, depending on the words language, must be the ISO 639-1 language code, default: EN\r\n   * @param {!number} [opts.heigth] desired height of the puzzle, default: smallest possible\r\n   * @param {!number} [opts.width] desired width of the puzzle, default: smallest possible\r\n   * @param {!Array.<string>} [opts.orientations=allOrientations] list the authorized orientations in which the words can be formed, default: allOrientations\r\n   * @param {!boolean} [opts.fillBlanks=true] do the game must fill the spaces not used to form a word with random letters, default: true\r\n   * @param {!boolean} [opts.allowExtraBlanks=true] can the game add additional blanks, default: true\r\n   * @param {!number} [opts.maxAttempts=3] number of tries before increasing puzzle size, default: 3\r\n   * @param {!number} [opts.maxGridGrowth=10] number of puzzle grid increases, default: 10\r\n   * @param {!boolean} [opts.preferOverlap=true] maximize word overlap or not, default: true\r\n   * @param {!boolean} [opts.debug=false] wether or not to print the puzzle to the console, default: false\r\n   * @memberof wordFind\r\n   */\r\n  constructor(words, domElem, opts = {}) {\r\n\r\n    if (!words.length) {\r\n      throw new Error('No words provided')\r\n    }\r\n    this.attempts = 0\r\n    this.gridGrowths = 0\r\n\r\n    this.domElem = domElem\r\n    this.allOrientations = ['horizontal','horizontalBack','vertical','verticalUp','diagonal','diagonalUp','diagonalBack','diagonalUpBack']\r\n    this.orientations = opts.orientations || allOrientations\r\n\r\n    /**\r\n     * @param {Array.<string>} wordList copy and sort the words by length, inserting words into the puzzle from longest to shortest works out the best\r\n     */\r\n    this.wordList = words.slice(0).sort()\r\n\r\n    // initialize the options\r\n    let maxWordLength = this.wordList[0].length\r\n    this.opts = {\r\n      lang: opts.lang || 'EN',\r\n      height: opts.height || maxWordLength,\r\n      width: opts.width || maxWordLength,\r\n      orientations: this.orientations,\r\n      fillBlanks: opts.fillBlanks !== undefined ? opts.fillBlanks : true,\r\n      allowExtraBlanks: opts.allowExtraBlanks !== undefined ? opts.allowExtraBlanks : true,\r\n      maxAttempts: opts.maxAttempts || 3,\r\n      maxGridGrowth: opts.maxGridGrowth !== undefined ? opts.maxGridGrowth : 10,\r\n      preferOverlap: opts.preferOverlap !== undefined ? opts.preferOverlap : true,\r\n      debug: opts.debug !== undefined ? opts.debug : false\r\n    }\r\n\r\n    this.lettersSet = this.setLetters(this.opts.lang)\r\n\r\n    this.startSquare = null\r\n    this.lastSquare = null\r\n    this.selectedSquares = []\r\n    this.curWord = ''\r\n    this.curOrientation = null\r\n\r\n    this.finalPuzzle = this.newPuzzle()\r\n    this.drawPuzzle()\r\n    this.setEventHandlers()\r\n\r\n    // this.startTurn = this.startTurn.bind(this)\r\n    // this.selectSquare = this.selectSquare.bind(this)\r\n    // this.endTurn = this.endTurn.bind(this)\r\n    // this.mouseMove = this.mouseMove.bind(this)\r\n    // this.touchMove = this.touchMove.bind(this)\r\n  }\r\n\r\n  /**\r\n   *Compute the next square given a starting square (x, y) and distance (i) from that square\r\n   * @param {!string} orientation\r\n   * @param {!number} x\r\n   * @param {!number} y\r\n   * @param {!number} i\r\n   * @returns {{x: !number, y: !number}} an object {x, y} representing the coordinates of the next square\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  compOrientations(orientation, x, y, i) {\r\n    switch(orientation) {\r\n      case 'horizontal':\r\n        return {x: x + i, y: y }\r\n\r\n      case 'horizontalBack':\r\n        return {x: x - i, y: y }\r\n\r\n      case 'vertical':\r\n        return {x: x,   y: y + i}\r\n\r\n      case 'verticalUp':\r\n        return {x: x,   y: y - i}\r\n\r\n      case 'diagonal':\r\n        return {x: x + i, y: y + i}\r\n\r\n      case 'diagonalBack':\r\n        return {x: x - i, y: y + i}\r\n\r\n      case 'diagonalUp':\r\n        return {x: x + i, y: y - i}\r\n\r\n      case 'diagonalUpBack':\r\n        return {x: x - i, y: y - i}\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   *Determines if an orientation is possible given the starting square (x, y), the height (h) and width (w) of the puzzle, and the length of the word (l)\r\n   * @param {!string} orientation\r\n   * @param {!number} x\r\n   * @param {!number} y\r\n   * @param {!number} h heigth of the puzzle\r\n   * @param {!number} w width of the puzzle\r\n   * @param {!number} l length of the word\r\n   * @returns {boolean} true if the word will fit starting at the square provided using the specified orientation\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  checkOrientations(orientation, x, y, h, w, l) {\r\n    switch(orientation) {\r\n      case 'horizontal':\r\n        return w >= x + l\r\n        \r\n      case 'horizontalBack':\r\n        return x + 1 >= l\r\n\r\n      case 'vertical':\r\n        return h >= y + l\r\n\r\n      case 'verticalUp':\r\n        return y + 1 >= l\r\n\r\n      case 'diagonal':\r\n        return (w >= x + l) && (h >= y + l)\r\n\r\n      case 'diagonalBack':\r\n        return (x + 1 >= l) && (h >= y + l)\r\n\r\n      case 'diagonalUp':\r\n        return (w >= x + l) && (y + 1 >= l)\r\n\r\n      case 'diagonalUpBack':\r\n        return (x + 1 >= l) && (y + 1 >= l)\r\n    }\r\n  }\r\n\r\n  /**\r\n   *Determines the next possible valid square given the square (x, y) and a word lenght of (l). This greatly reduces the number of squares that must be checked. Returning {x: x + 1, y: y} will always work but will not be optimal.\r\n   * @param {!string} orientation\r\n   * @param {!number} x\r\n   * @param {!number} y\r\n   * @param {!number} l length of the word\r\n   * @returns {{x: number, y: number}} an object {x, y} representing the coordinates of the next square\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  skipOrientations(orientation, x, y, l) {\r\n    switch(orientation) {\r\n      case 'horizontal':\r\n        return {x: 0, y: y + 1}\r\n\r\n      case 'horizontalBack':\r\n        return {x: l - 1, y: y}\r\n\r\n      case 'vertical':\r\n        return {x: 0, y: y + 100}\r\n\r\n      case 'verticalUp':\r\n        return {x: 0, y: l - 1}\r\n\r\n      case 'diagonal':\r\n        return {x: 0, y: y + 1}\r\n\r\n      case 'diagonalBack':\r\n        return {x: l - 1, y: x >= l - 1 ? y + 1 : y}\r\n\r\n      case 'diagonalUp':\r\n        return {x: 0, y: y < l - 1 ? l - 1 : y + 1}\r\n\r\n      case 'diagonalUpBack':\r\n        return {x: l - 1, y: x >= l - 1 ? y + 1 : y}\r\n    }\r\n  }\r\n\r\n  /**\r\n   *Initializes the puzzle and places words in the puzzle one at a time\r\n   * @param {Array.<string>} wordsList The list of words to fit into the puzzle\r\n   * @param {Object} opts The options to use when filling the puzzle\r\n   * @param {number} opts.height Height of the puzzle\r\n   * @param {number} opts.width Width of the puzzle\r\n   * @returns {Array.<Array>} Returns either a valid puzzle with all of the words or null if a valid\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  fillPuzzle(wordsList, opts) {\r\n    let i, j, len\r\n    // initialize the puzzle with blanks\r\n    this.curPuzzle = []\r\n    for (i = 0; i < opts.height; i++) {\r\n      this.curPuzzle.push([])\r\n      for (j = 0; j < opts.width; j++) {\r\n        this.curPuzzle[i].push('')\r\n      }\r\n    }\r\n\r\n    // add each word into the puzzle one at a time\r\n    for (i = 0, len = wordsList.length; i < len; i++) {\r\n      if (!this.placeWordInPuzzle(this.curPuzzle, opts, wordsList[i])) {\r\n        // if a word didn't fit in the puzzle, give up\r\n        return null\r\n      }\r\n    }\r\n\r\n    // return the puzzle\r\n    return this.curPuzzle\r\n  }\r\n\r\n  /**\r\n   *Adds the specified word to the puzzle by finding all of the possible locations where the word will fit and then randomly selecting one\r\n   * @param {Array.<Array>} puzzle current state of the puzzle\r\n   * @param {Object} opts controls whether or not word overlap should be maximized\r\n   * @param {string} word word to fit into the puzzle\r\n   * @returns {boolean} true if the word was successfully placed, false otherwise\r\n   * @memberof wordFind\r\n   */\r\n  placeWordInPuzzle(puzzle, opts, word) {\r\n    // find all of the best locations where this word would fit\r\n    let locations = this.findBestLocations(puzzle, opts, word)\r\n\r\n    if (locations.length === 0) {\r\n      return false\r\n    }\r\n\r\n    // select a location at random and place the word there\r\n    let sel = locations[Math.floor(Math.random() * locations.length)]\r\n    this.placeWord(puzzle, word, sel.x, sel.y, sel.orientation)\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   *Iterates through the puzzle and determines all of the locations where the word fit\r\n   * @param {Array.<Array>} puzzle current state of the puzzle\r\n   * @param {Object} options determines if overlap should be maximized or not\r\n   * @param {string} word word to fit into the puzzle\r\n   * @returns {Array.<{locations: Array.<{x: number, y: number}>, orientation: string, overlap: number}>} list of location objects which contain an x, y coordinate indicating the start of the word, the orientation of the word, and the number of letters that overlapped with existing letter\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  findBestLocations(puzzle, options, word) {\r\n    let locations = [],\r\n        height = options.height,\r\n        width = options.width,\r\n        wordLength = word.length,\r\n        maxOverlap = 0\r\n\r\n    // loop through all of the possible orientations at this position\r\n    for (let k = 0, len = options.orientations.length; k < len; k++) {\r\n      let orientation = options.orientations[k], x = 0, y = 0\r\n\r\n      // loop through every position on the board\r\n      while( y < height ) {\r\n\r\n        // see if this orientation is even possible at this location\r\n        if (this.checkOrientations(orientation, x, y, height, width, wordLength)) {\r\n          // determine if the word fits at the current position\r\n          var overlap = this.calcOverlap(word, puzzle, x, y, orientation)\r\n\r\n          // if the overlap was bigger than previous overlaps that we've seen\r\n          if (overlap >= maxOverlap || (!options.preferOverlap && overlap > -1)) {\r\n            maxOverlap = overlap\r\n            locations.push({\r\n              x: x, y: y,\r\n              orientation: orientation,\r\n              overlap: overlap})\r\n          }\r\n\r\n          x++\r\n\r\n          if (x >= width) {\r\n            x = 0\r\n            y++\r\n          }\r\n        } else {\r\n          // if current cell is invalid, then skip to the next cell where this orientation is possible. this greatly reduces the number of checks that we have to do overall\r\n          let nextPossible = this.skipOrientations(orientation, x, y, wordLength)\r\n          x = nextPossible.x\r\n          y = nextPossible.y\r\n        }\r\n      }\r\n    }\r\n\r\n    // finally prune down all of the possible locations we found by\r\n    // only using the ones with the maximum overlap that we calculated\r\n    return options.preferOverlap ?\r\n      this.pruneLocations(locations, maxOverlap) :\r\n      locations\r\n  }\r\n\r\n  /**\r\n   *Determines whether or not a particular word fits in a particular\r\n  * orientation within the puzzle\r\n  * @param {string} word word to fit into the puzzle.\r\n  * @param {Array.<Array>} puzzle current state of the puzzle\r\n  * @param {number} x\r\n  * @param {number} y\r\n  * @param {string} orientation orientation to use when computing the next square\r\n  * @returns {number} number of letters overlapped with existing words if the word fits in the specified position, -1 if the word does not fit\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  calcOverlap(word, puzzle, x, y, orientation) {\r\n    let overlap = 0\r\n\r\n    // traverse the squares to determine if the word fits\r\n    for (let i = 0, len = word.length; i < len; i++) {\r\n\r\n      var next = this.compOrientations(orientation, x, y, i),\r\n          square = puzzle[next.y][next.x]\r\n\r\n      // if the puzzle square already contains the letter we are looking for, then count it as an overlap square\r\n      if (square === word[i]) {\r\n        overlap++\r\n      }\r\n      // if it contains a different letter, than our word doesn't fit here, return -1\r\n      else if (square !== '' ) {\r\n        return -1\r\n      }\r\n    }\r\n\r\n    // if the entire word is overlapping, skip it to ensure words aren't hidden in other words\r\n    return overlap\r\n  }\r\n\r\n  /**\r\n   *If overlap maximization is true, this function is used to prune the list of valid locations down to the ones that contain the maximum overlap that was previously calculated\r\n   * @param {Array.<{x: number, y: number}} locations set of locations to prune\r\n   * @param {number} overlap required level of overlap\r\n   * @returns {Array.<{x: number, y: number}} pruned set of locations\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  pruneLocations(locations, overlap) {\r\n    var pruned = []\r\n    for (let i = 0, len = locations.length; i < len; i++) {\r\n      if (locations[i].overlap >= overlap) {\r\n        pruned.push(locations[i])\r\n      }\r\n    }\r\n    return pruned\r\n  }\r\n\r\n  /**\r\n   *Places a word in the puzzle given a starting position and orientation\r\n   * @param {Array.<Array>} puzzle current state of the puzzle\r\n   * @param {string} word word to fit into the puzzle\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {string} orientation orientation to use when computing the next squares\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  placeWord(puzzle, word, x, y, orientation) {\r\n    for (let i = 0, len = word.length; i < len; i++) {\r\n      let next = this.compOrientations(orientation, x, y, i)\r\n      puzzle[next.y][next.x] = word[i]\r\n    }\r\n  }\r\n\r\n  /**\r\n   *Define the letters set \r\n   * @param {!string} [lang=this.opts.lang] ISO 639-1 language code\r\n   * @returns {!string} a string including every character in the set\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  setLetters(lang = this.opts.lang) {\r\n    switch(lang) {\r\n      case 'EN':\r\n        return 'abcdefghijklmnoprstuvwy'\r\n\r\n          \r\n      case 'ES':\r\n        return 'abcdefghijklmnoprstuvwy'\r\n\r\n      \r\n      case 'FR':\r\n        return 'abcdefghijklmnoprstuvwyéàèùâêîôûçëïü'\r\n\r\n      \r\n      case 'IT':\r\n        return 'abcdefghijklmnoprstuvwyàèéìòóù'\r\n\r\n      \r\n      case 'DE':\r\n        return 'abcdefghijklmnoprstuvwyäöüß'\r\n\r\n      \r\n      case 'JA':\r\n        return 'アカサタナイキシチニウクスツヌエケセテネオコソトノハマヤラワヒミリヰフムユルンヘメレヱホモヨロヲガザダバパギジヂビピグズヅブプゲゼデベペゴゾドボポ'\r\n\r\n      \r\n      case 'ZH':\r\n        return '安吧爸八百北不大岛的弟地东都对多儿二方港哥个关贵国过海好很会家见叫姐京九可老李零六吗妈么没美妹们明名哪那南你您朋七起千去人认日三上谁什生师识十是四他她台天湾万王我五西息系先香想小谢姓休学也一亿英友月再张这中字'\r\n\r\n      \r\n      case 'HI':\r\n        return 'अआएईऍऎऐइओऑऒऊऔउबभचछडढफफ़गघग़हजझकखख़लळऌऴॡमनङञणऩॐपक़रऋॠऱसशषटतठदथधड़ढ़वयय़ज़'\r\n\r\n      \r\n      case 'ID':\r\n        return 'abcdefghijklmnoprstuvwy'\r\n\r\n      \r\n      case 'NL':\r\n        return 'abcdefghijklmnoprstuvwyáéíóúàèëïöüĳ'\r\n\r\n      \r\n      case 'PL':\r\n        return 'abcdefghijklmnoprstuvwyąćęłńóśżź'\r\n\r\n      \r\n      case 'PT':\r\n        return 'abcdefghijklmnoprstuvwyàáâãçéêíóôõú'\r\n\r\n      \r\n      case 'RU':\r\n        return 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'\r\n\r\n      \r\n      case 'KO':\r\n        return 'ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅓㅗㅜㅡㅣㅑㅕㅛㅠㄲㄸㅃㅆㅉㄳㄵㄶㄺㄻㄼㄽㄾㄿㅀㅄㅐㅒㅔㅖㅢㅘㅙㅚㅝㅞㅟ'\r\n\r\n      \r\n      default:\r\n        console.warn('Language not recognized, falling back to English')\r\n        return 'abcdefghijklmnoprstuvwy'\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Array.<string>} [wordList=this.wordList]\r\n   * @param {Object} [options=this.opts]\r\n   * @returns {Array.<Array>}\r\n   * @memberof wordFind\r\n   */\r\n  newPuzzle(wordList = this.wordList, options = this.opts) {\r\n    // add the words to the puzzle\r\n    // since puzzles are random, attempt to create a valid one up to maxAttempts and then increase the puzzle size and try again\r\n    while (!this.curPuzzle) {\r\n      while (!this.curPuzzle && this.attempts++ < options.maxAttempts) {\r\n        this.curPuzzle = this.fillPuzzle(wordList, options)\r\n      }\r\n\r\n      if (!this.curPuzzle) {\r\n        this.gridGrowths++\r\n        if (this.gridGrowths > options.maxGridGrowth) {\r\n          throw new Error(`No valid ${options.width}x${options.height} grid found and not allowed to grow more`)\r\n        }\r\n        console.log(`No valid ${options.width}x${options.height} grid found after ${this.attempts - 1} attempts, trying with bigger grid`)\r\n        options.height++\r\n        options.width++\r\n        this.attempts = 0\r\n      }\r\n    }\r\n\r\n    // fill in empty spaces with random letters\r\n    if (options.fillBlanks) {\r\n      for (let i = 0, k = this.curPuzzle.length ; i < k ; i++) {\r\n        for (let j = 0, l = this.curPuzzle[i].length ; j < l ; j++) {\r\n          if(this.curPuzzle[i][j] == '') {\r\n            this.curPuzzle[i][j] = this.lettersSet[Math.floor(Math.random() * this.lettersSet.length)]\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if(options.debug) {this.print(this.curPuzzle)}\r\n    return this.curPuzzle\r\n  }\r\n\r\n  /**\r\n  *Wrapper around `newPuzzle` allowing to find a solution without some words\r\n  * @param {Object} opts options to use for this puzzle\r\n  */\r\n  newPuzzleLax(words, opts) {\r\n    try {\r\n      return this.newPuzzle(words, opts);\r\n    } catch (e) {\r\n      if (!opts.allowedMissingWords) {\r\n        throw e\r\n      }\r\n      var opts = Object.assign({}, opts); // shallow copy\r\n      opts.allowedMissingWords--\r\n      for (var i = 0; i < words.length; i++) {\r\n        var wordList = words.slice(0)\r\n        wordList.splice(i, 1)\r\n        try {\r\n          this.curPuzzle = this.newPuzzleLax(wordList, opts)\r\n          console.log(`Solution found without word \"${words[i]}\"`)\r\n          return this.curPuzzle\r\n        } catch (e) {}\r\n      }\r\n      throw e\r\n    }\r\n  }\r\n\r\n  /**\r\n   *Returns the starting location and orientation of the specified words within the puzzle. Any words that are not found are returned in the notFound array\r\n   * @param {Array.<Array>} puzzle\r\n   * @param {Array.<string>} words\r\n   * @returns {Array.<{x: number, y: number, orientation: string, word: string, overlap: number}>}\r\n   * @public\r\n   * @memberof wordFind\r\n   */\r\n  solve(puzzle, words) {\r\n    var options = {\r\n          height:       puzzle.length,\r\n          width:        puzzle[0].length,\r\n          orientations: this.orientations,\r\n          preferOverlap: true\r\n        },\r\n        found = [],\r\n        notFound = []\r\n\r\n    for(var i = 0, len = words.length; i < len; i++) {\r\n      let word = words[i],\r\n          locations = this.findBestLocations(puzzle, options, word)\r\n\r\n      if (locations.length > 0 && locations[0].overlap === word.length) {\r\n        locations[0].word = word\r\n        found.push(locations[0])\r\n      } else {\r\n        notFound.push(word)\r\n      }\r\n    }\r\n\r\n    return { found: found, notFound: notFound }\r\n  }\r\n\r\n  /**\r\n   *Outputs a puzzle to the console, useful for debugging\r\n   * @param {Array.<Array>} puzzle current state of the puzzle\r\n   * @returns {string} formatted string representing the puzzle\r\n   * @memberof wordFind\r\n   */\r\n  print(puzzle) {\r\n    let puzzleString = ''\r\n    for (var i = 0, height = puzzle.length; i < height; i++) {\r\n      var row = puzzle[i]\r\n      for (var j = 0, width = row.length; j < width; j++) {\r\n        puzzleString += (row[j] === '' ? ' ' : row[j]) + ' '\r\n      }\r\n      puzzleString += '\\n'\r\n    }\r\n\r\n    console.log(puzzleString)\r\n    return puzzleString\r\n  }\r\n\r\n  /**\r\n   *Draws the puzzle by inserting rows of buttons into the DOM Element\r\n   * @param {HTMLElement} [domElem=this.domElem]\r\n   * @param {Array.<Array>} [puzzle=this.finalPuzzle]\r\n   * @memberof wordFind\r\n   */\r\n  drawPuzzle(domElem = this.domElem, puzzle = this.finalPuzzle) {\r\n    while (domElem.firstChild) {\r\n      domElem.removeChild(domElem.firstChild);\r\n    }\r\n    // for each row in the puzzle\r\n    for (var i = 0, height = puzzle.length; i < height; i++) {\r\n      // append a div to represent a row in the puzzle\r\n      let div = document.createElement('div');\r\n      var row = puzzle[i];\r\n      // for each element in that row\r\n      for (var j = 0, width = row.length; j < width; j++) {\r\n        // append our button with the appropriate class\r\n        let btn = document.createElement('button');\r\n        btn.classList.add('puzzleSquare');\r\n        btn.setAttribute('x', j);\r\n        btn.setAttribute('y', i);\r\n        let btnTxt = document.createTextNode(row[j] || '&nbsp;');\r\n        btn.appendChild(btnTxt);\r\n        div.appendChild(btn);\r\n      }\r\n      // close our div that represents a row\r\n      domElem.appendChild(div);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *Given two points, ensure that they are adjacent and determine what orientation the second point is relative to the first\r\n   * @param {number} x1 x coordinate of the first point\r\n   * @param {number} y1 y coordinate of the first point\r\n   * @param {number} x2 x coordinate of the second point\r\n   * @param {number} y2 y coordinate of the second point\r\n   * @returns {string} matching orientation\r\n   * @private\r\n   * @memberof wordFind\r\n   */\r\n  calcOrientation(x1, y1, x2, y2) {\r\n    for (let i = 0 ; i < this.orientations.length ; i++) {\r\n      let nextPos = this.compOrientations(this.orientations[i], x1, y1, 1)\r\n\r\n      if (nextPos.x === x2 && nextPos.y === y2) {\r\n        return this.orientations[i]\r\n      }\r\n\r\n      return null\r\n    }\r\n  }\r\n\r\n  startTurn(e) {\r\n    let elem = e.target\r\n    elem.classList.add('selected')\r\n    this.startSquare = elem\r\n    this.selectedSquares.push(elem)\r\n    this.curWord = elem.innerText\r\n  }\r\n\r\n  mouseMove(e) {\r\n    let elem = e.target\r\n    this.selectSquare(elem)\r\n  }\r\n\r\n  touchMove(e) {\r\n    let xPos = e.touches[0].pageX\r\n    let yPos = e.touches[0].pageY\r\n    let elem = document.elementFromPoint(xPos, yPos)\r\n    this.selectSquare(elem)\r\n  }\r\n\r\n  selectSquare(elem) {\r\n    let lastSquare = this.selectedSquares[this.selectedSquares.length - 1]\r\n    if (this.startSquare && elem !== this.startSquare) {\r\n      let orientation = this.calcOrientation(\r\n        lastSquare.getAttribute('x'),\r\n        lastSquare.getAttribute('y'),\r\n        elem.getAttribute('x'),\r\n        elem.getAttribute('y'),\r\n      )\r\n      if (this.curOrientation == '' || this.curOrientation == orientation) {\r\n        this.playTurn(elem)\r\n      } else {\r\n        this.endTurn()\r\n      }\r\n    }    \r\n  }\r\n\r\n  playTurn(elem) {\r\n    for (var i = 0, len = this.wordList.length; i < len; i++) {\r\n      if (this.wordList[i].toUpperCase().indexOf(this.curWord + elem.innerText) === 0) {\r\n        elem.classList.add('selected')\r\n        this.selectedSquares.push(elem)\r\n        this.curWord += elem.innerText\r\n      }\r\n    }\r\n  }\r\n\r\n  endTurn() {\r\n    for (let i = 0 ; i < this. wordList.length ; i++) {\r\n      if (this.wordList[i].toUpperCase() === this.curWord) {\r\n        let selected = document.querySelectorAll('.selected');\r\n        [].forEach.call(selected, (item) => {\r\n          item.classList.add('found')\r\n        })\r\n        this.wordList.splice(i, 1)\r\n      }\r\n\r\n      if (this.wordList.length === 0) {\r\n        let completed = document.querySelectorAll('.puzzleSquare');\r\n        [].forEach.call(completed, (item) => {\r\n          item.classList.add('complete')\r\n        })\r\n      }\r\n    }\r\n\r\n    // reset the turn\r\n    let selected = document.querySelectorAll('.selected');\r\n    [].forEach.call(selected, (item) => {\r\n      item.classList.remove('selected')\r\n    })\r\n    this.startSquare = null\r\n    this.lastSquare = null\r\n    this.selectedSquares = []\r\n    this.curWord = ''\r\n    this.curOrientation = null\r\n  }\r\n\r\n  \r\n\r\n  /**\r\n   *Set the event handlers that will trigger the recognition of the words\r\n   * @param {HTMLElement} [domElem=this.domElem]\r\n   * @memberof wordFind\r\n   */\r\n  setEventHandlers(domElem = this.domElem) {\r\n    if (window.navigator.msPointerEnabled) {\r\n      let puzzleSquare = domElem.querySelectorAll('.puzzleSquare');\r\n      [].forEach.call(puzzleSquare, (item) => {\r\n        item.addEventListener('MSPointerDown', this.startTurn.bind(this))\r\n        item.addEventListener('MSPointerOver', this.selectSquare.bind(this))\r\n        item.addEventListener('MSPointerUp', this.endTurn.bind(this))\r\n      })\r\n    } else {\r\n      let puzzleSquare = domElem.querySelectorAll('.puzzleSquare');\r\n      [].forEach.call(puzzleSquare, (item) => {\r\n        item.addEventListener('mousedown', this.startTurn.bind(this))\r\n        item.addEventListener('mouseenter', this.mouseMove.bind(this))\r\n        item.addEventListener('mouseup', this.endTurn.bind(this))\r\n        item.addEventListener('touchstart', this.startTurn.bind(this))\r\n        item.addEventListener('touchmove', this.touchMove.bind(this))\r\n        item.addEventListener('touchend', this.endTurn.bind(this))\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport default wordFind"],"sourceRoot":""}